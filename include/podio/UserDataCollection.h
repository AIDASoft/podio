#ifndef PODIO_USERDATACOLLECTION_H
#define PODIO_USERDATACOLLECTION_H

#include "podio/CollectionBase.h"
#include "podio/CollectionBuffers.h"
#include "podio/DatamodelRegistry.h"
#include "podio/SchemaEvolution.h"
#include "podio/utilities/TypeHelpers.h"
#include "podio/utilities/UserDataHelpers.h"

#include <map>
#include <string>
#include <typeindex>
#include <utility>
#include <vector>

#define PODIO_ADD_USER_TYPE(type)                                                                                      \
  template <>                                                                                                          \
  constexpr const char* userDataTypeName<type>() {                                                                     \
    return #type;                                                                                                      \
  }                                                                                                                    \
  template <>                                                                                                          \
  constexpr const char* userDataCollTypeName<type>() {                                                                 \
    return "podio::UserDataCollection<" #type ">";                                                                     \
  }

namespace podio {

/** tuple of basic types supported in user vector
 */
using SupportedUserDataTypes =
    std::tuple<float, double, int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t>;

/**
 * Static bool for determining whether a type T is a supported user data type.
 * Effectively boils down to being listed in SupportedUserDataTypes or being a
 * component of an EDM generated by podio.
 */
template <typename T>
constexpr static bool isSupportedUserDataType = detail::isInTuple<T, SupportedUserDataTypes> || detail::isComponent<T>;

/**
 * Alias template to be used to enable template specializations only for types
 * that are actually supported user data types
 */
template <typename T>
using EnableIfSupportedUserType = std::enable_if_t<isSupportedUserDataType<T>>;

/** helper template to provide readable type names for basic types with macro PODIO_ADD_USER_TYPE(type)
 */
template <typename BasicType>
inline constexpr const char* userDataTypeName();

/** Helper template to provide the fully qualified name of a UserDataCollection.
 * Implementations are populated by the PODIO_ADD_USER_TYPE macro.
 */
template <typename BasicType>
inline constexpr const char* userDataCollTypeName();

PODIO_ADD_USER_TYPE(float)
PODIO_ADD_USER_TYPE(double)
PODIO_ADD_USER_TYPE(int8_t)
PODIO_ADD_USER_TYPE(int16_t)
PODIO_ADD_USER_TYPE(int32_t)
PODIO_ADD_USER_TYPE(int64_t)
PODIO_ADD_USER_TYPE(uint8_t)
PODIO_ADD_USER_TYPE(uint16_t)
PODIO_ADD_USER_TYPE(uint32_t)
PODIO_ADD_USER_TYPE(uint64_t)

// don't make this macro public as it should only be used internally here...
#undef PODIO_ADD_USER_TYPE

/** Collection of basic types for additional user data not defined in the EDM.
 *  The data is stored in an std::vector<basic_type>. Supported are all basic types supported in
 *  PODIO, i.e. float, double and 8-64 bit fixed size signed and unsigned integers - @see SupportedUserDataTypes.
 *  @author F.Gaede, DESY
 *  @date Sep 2021
 */
template <typename BasicType, typename = EnableIfSupportedUserType<BasicType>>
class UserDataCollection : public CollectionBase {

private:
  std::vector<BasicType> _vec{};
  // Pointer to the actual storage, necessary for I/O. In order to have
  // simpler move-semantics this will be set and properly initialized on
  // demand during the call to getBuffers
  std::vector<BasicType>* _vecPtr{nullptr};
  uint32_t m_collectionID{0};
  CollRefCollection m_refCollections{};
  VectorMembersInfo m_vecmem_info{};

public:
  UserDataCollection() = default;
  /// Constructor from an existing vector (wich will be moved from!)
  UserDataCollection(std::vector<BasicType>&& vec) : _vec(std::move(vec)) {
  }
  UserDataCollection(const UserDataCollection&) = delete;
  UserDataCollection& operator=(const UserDataCollection&) = delete;
  UserDataCollection(UserDataCollection&&) = default;
  UserDataCollection& operator=(UserDataCollection&&) = default;
  ~UserDataCollection() = default;

  /// The schema version of UserDataCollections
  static constexpr SchemaVersionT schemaVersion = 1;

  constexpr static auto typeName = userDataCollTypeName<BasicType>();
  constexpr static auto valueTypeName = userDataTypeName<BasicType>();
  constexpr static auto dataTypeName = userDataTypeName<BasicType>();

  /// prepare buffers for serialization
  void prepareForWrite() const override {
  }

  /// re-create collection from buffers after read
  void prepareAfterRead() override {
  }

  /// initialize references after read
  bool setReferences(const ICollectionProvider*) override {
    return true;
  }

  /// set collection ID
  void setID(uint32_t id) override {
    m_collectionID = id;
  }

  /// get collection ID
  uint32_t getID() const override {
    return m_collectionID;
  }

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() override {
    _vecPtr = &_vec; // Set the pointer to the correct internal vector
    return {&_vecPtr, _vecPtr, &m_refCollections, &m_vecmem_info};
  }

  /// check for validity of the container after read
  bool isValid() const override {
    return true;
  }

  /// number of elements in the collection
  size_t size() const override {
    return _vec.size();
  }

  /// Is the collection empty
  bool empty() const override {
    return _vec.empty();
  }

  /// fully qualified type name
  const std::string_view getTypeName() const override {
    return typeName;
  }

  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const override {
    return valueTypeName;
  }

  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const override {
    return dataTypeName;
  }

  /// clear the collection and all internal states
  void clear() override {
    _vec.clear();
  };

  /// check if this collection is a subset collection - no subset possible
  bool isSubsetCollection() const override {
    return false;
  }

  /// declare this collection to be a subset collectionv - no effect
  void setSubsetCollection(bool) override {
  }

  /// The schema version is fixed manually
  SchemaVersionT getSchemaVersion() const final {
    return schemaVersion;
  }

  /// Print this collection to the passed stream
  void print(std::ostream& os = std::cout, bool flush = true) const override {
    os << "[";
    if (!_vec.empty()) {
      os << _vec[0];
      for (size_t i = 1; i < _vec.size(); ++i) {
        os << ", " << _vec[i];
      }
    }
    os << "]";

    if (flush) {
      os.flush(); // Necessary for python
    }
  }

  size_t getDatamodelRegistryIndex() const override {
    return DatamodelRegistry::NoDefinitionNecessary;
  }

  // ----- some wrapers for std::vector and access to the complete std::vector (if really needed)

  typename std::vector<BasicType>::iterator begin() {
    return _vec.begin();
  }
  typename std::vector<BasicType>::iterator end() {
    return _vec.end();
  }
  typename std::vector<BasicType>::const_iterator begin() const {
    return _vec.begin();
  }
  typename std::vector<BasicType>::const_iterator end() const {
    return _vec.end();
  }

  typename std::vector<BasicType>::reference operator[](size_t idx) {
    return _vec[idx];
  }
  typename std::vector<BasicType>::const_reference operator[](size_t idx) const {
    return _vec[idx];
  }

  void resize(size_t count) {
    _vec.resize(count);
  }
  void push_back(const BasicType& value) {
    _vec.push_back(value);
  }

  /// access to the actual data vector
  typename std::vector<BasicType>& vec() {
    return _vec;
  }

  /// const access to the actual data vector
  const typename std::vector<BasicType>& vec() const {
    return _vec;
  }
};

template <typename BasicType, typename = EnableIfSupportedUserType<BasicType>>
std::ostream& operator<<(std::ostream& o, const podio::UserDataCollection<BasicType>& coll) {
  coll.print(o);
  return o;
}
} // namespace podio

#include "podio/CollectionBufferFactory.h"

namespace podio::detail {
/**
 * Helper function to register a UserDataCollection to the
 * CollectionBufferFactory. Takes the BasicType as template argument.
 *
 * Returns an integer so that it can be used with std::apply
 */
template <typename T>
int registerUserDataCollection(T) {
  using CollType = podio::UserDataCollection<T>;
  // Register with schema version 1 to allow for potential changes
  CollectionBufferFactory::mutInstance().registerCreationFunc(
      CollType::typeName, UserDataCollection<T>::schemaVersion, [](bool) {
        return podio::CollectionReadBuffers{
            new std::vector<T>(),
            nullptr,
            nullptr,
            CollType::schemaVersion,
            CollType::typeName,
            [](podio::CollectionReadBuffers buffers, bool) {
              return std::make_unique<UserDataCollection<T>>(std::move(*buffers.dataAsVector<T>()));
            },
            [](podio::CollectionReadBuffers& buffers) {
              buffers.data = podio::CollectionWriteBuffers::asVector<T>(buffers.data);
            },
            [](podio::CollectionReadBuffers& buffers) { delete static_cast<std::vector<T>*>(buffers.data); }};
      });

  // For now passing the same schema version for from and current versions
  // just to make SchemaEvolution aware of UserDataCollections.
  podio::SchemaEvolution::mutInstance().registerEvolutionFunc(
      CollType::typeName, CollType::schemaVersion, CollType::schemaVersion, SchemaEvolution::noOpSchemaEvolution,
      SchemaEvolution::Priority::AutoGenerated);

  return 1;
}
} // namespace podio::detail

#endif
