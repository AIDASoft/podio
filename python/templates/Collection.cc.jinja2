{% import "macros/utils.jinja2" as utils %}
{% import "macros/collections.jinja2" as macros %}
{% from "macros/iterator.jinja2" import iterator_definitions %}
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#include "{{ incfolder }}{{ class.bare_type }}Collection.h"

{% for include in includes_coll_cc %}
{{ include }}
{% endfor %}

// standard includes
#include <stdexcept>
#include <iomanip>

{{ utils.namespace_open(class.namespace) }}

{% with collection_type = class.bare_type + 'Collection' %}
{{ collection_type }}::{{ collection_type }}() :
  m_isValid(false), m_isReadFromFile(false), m_collectionID(0), m_storage() {}

{{ collection_type }}::~{{ collection_type }}() {
  clear();
}

Const{{ class.bare_type }} {{ collection_type }}::operator[](unsigned int index) const {
  return Const{{ class.bare_type }}(m_storage.entries[index]);
}

Const{{ class.bare_type }} {{ collection_type }}::at(unsigned int index) const {
  return Const{{ class.bare_type }}(m_storage.entries.at(index));
}

{{ class.bare_type }} {{ collection_type }}::operator[](unsigned int index) {
  return {{ class.bare_type }}(m_storage.entries[index]);
}

{{ class.bare_type }} {{ collection_type }}::at(unsigned int index) {
  return {{ class.bare_type }}(m_storage.entries.at(index));
}

size_t {{ collection_type }}::size() const {
  return m_storage.entries.size();
}

{{ class.bare_type }} {{ collection_type }}::create() {
  auto obj = m_storage.entries.emplace_back(new {{ class.bare_type }}Obj());
{% if OneToManyRelations or VectorMembers %}
  m_storage.createRelations(obj);
{% endif %}

  obj->id = {int(m_storage.entries.size() - 1), m_collectionID};
  return {{ class.bare_type }}(obj);
}

void {{ collection_type }}::clear() {
  m_storage.clear();
}

void {{ collection_type }}::prepareForWrite() {
  // If the collection has been read from a file, there is nothing to do here
  if (m_isReadFromFile) return;
  m_storage.prepareForWrite();
}

void {{ collection_type }}::prepareAfterRead() {
  m_storage.prepareAfterRead(m_collectionID);
  m_isReadFromFile = true;
}

bool {{ collection_type }}::setReferences(const podio::ICollectionProvider* {% if OneToManyRelations or OneToOneRelations -%}collectionProvider{%- endif -%}) {
{% if OneToManyRelations or OneToOneRelations %}
  m_storage.setReferences(collectionProvider);
{% endif %}

  return true; //TODO: check success
}

void {{ collection_type }}::push_back(Const{{ class.bare_type }} object) {
  const auto size = m_storage.entries.size();
  auto obj = object.m_obj;
  if (obj->id.index == podio::ObjectID::untracked) {
    obj->id = {(int)size, m_collectionID};
    m_storage.entries.push_back(obj);
{% if OneToManyRelations or VectorMembers %}
    m_storage.createRelations(obj);
{% endif %}
  } else {
    throw std::invalid_argument("Object already in a collection. Cannot add it to a second collection");
  }
}

podio::CollectionBuffers {{ collection_type }}::getBuffers() {
  return m_storage.getCollectionBuffers();
}

// void {{ collection_type }}::setBuffers(const podio::CollectionBuffers& buffers) {
//   if (m_storage.data) delete m_storage.data;
//   m_storage.data = static_cast<{{ class.bare_type }}DataContainer*>(buffers.data);

//   m_storage.vecmem_info = std::move(*buffers.vectorMembers);
//   m_storage.refCollections = std::move(*buffers.references);
// }
{% endwith %}

{{ iterator_definitions(class) }}

{{ iterator_definitions(class, prefix='Const' ) }}

{{ macros.ostream_operator(class, Members, OneToOneRelations, OneToManyRelations, VectorMembers, use_get_syntax, ostream_collection_settings) }}

{{ utils.namespace_close(class.namespace) }}
